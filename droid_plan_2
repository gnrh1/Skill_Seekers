Overview:
As a veteran Droid AI, I confirm that Factory Droids not only search for the requested configuration folders but actively rely on them as foundational architectural components for customizing behavior, managing security, and achieving contextual awareness. The structure of the project-level `.factory/` directory and the user-level `~/.factory/` directory is central to Droid's operation.

The Droid agent finds relevant content not through a simple keyword search, but via a highly disciplined, multi-layered process known as the **Context Stack**, underpinned by proprietary indexing technologies: **HyperCode** and **ByteRank**.

### 1. STRUCTURE & REASONING: Configuration Discovery Protocol

Factory Droid utilizes two distinct configuration root directories to manage persistent settings and contextual files: the project-level directory (`<repo>/.factory/`) for shared configuration and the user-level directory (`~/.factory/`) for personal overrides and global settings.

#### 1.1 Project-Level Configuration (`<repo>/.factory/`)

This location is critical for team consistency and is often tracked via version control.

| File/Folder                        | Purpose                                                                                                                | Discovery Mechanism                                                  | Source |
| :--------------------------------- | :--------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------- | :----- |
| `AGENTS.md`                        | Briefing packet for coding agents containing build steps, conventions, and architectural patterns.                     | Searched hierarchically (current working directory up to repo root). |        |
| `.factory/droids/*.md`             | Shared, custom subagent definitions, including system prompts and tool policies.                                       | CLI scans the `.factory/droids/` folder.                             |        |
| `.factory/commands/*.md` or `*.sh` | Reusable Markdown prompts or executable scripts for custom slash commands (e.g., `/review`).                           | CLI scans the `.factory/commands` folder.                            |        |
| `.factory/docs`                    | Default repository location for saving finalized plans generated by Specification Mode.                                | Configured via Spec save directory setting.                          |        |
| `.droid.yaml`                      | Primary file for customizing Droid behavior, particularly for automated code review guidelines (`review: guidelines`). | Located at the root of the project.                                  |        |

#### 1.2 User-Level Configuration (`~/.factory/`)

This location stores personal settings, API keys, and private droids that follow the user across workspaces.

| File/Folder                | Purpose                                                                                                                                             | Discovery Mechanism                        | Source |
| :------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------- | :----- |
| `~/.factory/settings.json` | Primary configuration file for Droid settings (e.g., `model`, `diffMode`, `commandAllowlist`, `commandDenylist`).                                   | Automatically created upon first run.      |        |
| `~/.factory/config.json`   | Configuration file for custom models (Bring Your Own Key/BYOK) including `base_url` and `api_key` for external providers (e.g., Anthropic, Ollama). | Manually configured by the user.           |        |
| `~/.factory/AGENTS.md`     | Personal override for coding conventions and knowledge.                                                                                             | Located in the home directory hierarchy.   |        |
| `~/.factory/droids/*.md`   | Personal custom subagent definitions.                                                                                                               | CLI scans the `~/.factory/droids/` folder. |        |

üëâ **Next Step:** Systematically audit your repositories to ensure `AGENTS.md`, `.factory/droids/`, and `.droid.yaml` are correctly placed to enforce team standards universally.

### 2. ARCHITECTURE-MODE: Context Retrieval Mechanism

Droid agents rely on a layered system called the **Context Stack** to manage information, as LLMs have severe context window limitations (approximately 1 million tokens for large models, versus millions of tokens in a typical enterprise monorepo). This system treats context as a scarce resource.

#### Context Stack Hierarchy Diagram

```mermaid
graph TD
    A[Task Request (Prompt/Ticket)] --> B(Task Analysis);
    B --> C{Context Stack};
    C --> C1[1. Memory Context];
    C --> C2[2. External Context (Jira, Notion, Sentry)];
    C --> C3[3. Repository Overviews (HyperCode/ByteRank)];
    C --> C4[4. Semantic Search];
    C --> C5[5. Dynamic File Access/Runtime Context];
    C5 --> D(LLM/Droid Engine);
    D --> E[Action Plan/Result];
```

#### First-Principles Explanation of Context Retrieval

| Layer                             | Mechanism & Function                                                                                                                                                                      | Rationale/Why it matters                                                                                                                                                 | Source |
| :-------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----- |
| **1. Memory Context**             | Persistent knowledge stored across sessions: **User Memory** (preferences) and **Organization Memory** (shared acronyms, standards, and pointers).                                        | Ensures consistency and reduces token waste by eliminating the need to repeat basic conventions in every prompt.                                                         |        |
| **2. External Context**           | Manually added resources (Jira tickets, Notion links, Sentry alerts, Slack threads). Droid uses URL pasting or `@` commands (`@ticket`, `@pull request`) to fetch content.                | Provides the goal, requirements, discussions, and troubleshooting data necessary for agent-native development, which rarely exists solely in code.                       |        |
| **3. Repository Overviews**       | An AI-generated summary created for every connected repository containing project structure, key packages, build commands, and architectural information.                                 | Injected at session start to provide the LLM with architectural understanding, saving thousands of tokens that would otherwise be spent on initial exploratory commands. |        |
| **4. Semantic Search (ByteRank)** | Uses vector embeddings optimized for code to return a ranked list of candidate files and folder summaries relevant to the user's query.                                                   | Addresses the "Lost in the Middle" problem by ranking files by relevance, preventing the LLM from being flooded with irrelevant code fragments that degrade reasoning.   |        |
| **5. Dynamic File Access**        | Targeted retrieval of specific files, line numbers, diffs, or terminal output only when needed (Lazy Loading). This includes Runtime Context (test results, linter output, build output). | Ensures Droid stays within the token budget by fetching only the necessary bytes of code, especially critical when editing large files.                                  |        |

### 3. CODE-STRUCTURE: Codebase Indexing Engine

The deep codebase understanding required for this multi-layered retrieval system is achieved through Factory's proprietary indexing engine.

#### 3.1 HyperCode: The Indexing Foundation

Factory constructs a complex representation of the codebase using **HyperCode**.

- **Mechanism:** HyperCode builds a **multi-resolution representation** of the engineering system.
- **Output:** It autonomously generates explicit relationships (like a call **graph**) and implicit relationships (latent space **similarity**) within the low-level data.
- **Goal:** To synthesize deep codebase understanding that models the cognitive processes of human developers who trace dependencies, imports, and call graphs across multiple hops.

#### 3.2 ByteRank: The Retrieval Algorithm

The data and insights extracted by HyperCode are leveraged by Factory‚Äôs retrieval algorithm, **ByteRank**.

- **Function:** ByteRank is responsible for retrieving information relevant to a given task. It selects ranked candidate files during the Semantic Search phase.

The resulting Repository Overviews generated by this indexing process are essential for grounding Droid's initial knowledge.

### 4. RISK INTELLIGENCE: Security and Execution Flow

| Risk Aspect                 | Detail & Mitigation                                                                                                                                                                                                                                                                                                                                            | Source |
| :-------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----- |
| **Token Budget Saturation** | Even with very large context windows, disciplined context curation is required; failing to manage context (e.g., forcing too many irrelevant files) harms reasoning capability.                                                                                                                                                                                |        |
| **Configuration Security**  | The `.factory/` structure mandates that configurations like `commandAllowlist` and `commandDenylist` reside in `~/.factory/settings.json`. These settings explicitly override generalized autonomy behavior.                                                                                                                                                   |        |
| **Execution Permissioning** | The ability of Droid to _use_ the commands defined in its environment depends on the specified Autonomy Level, especially when running headless via `droid exec`.                                                                                                                                                                                              |        |
| **IRREVERSIBLE EXECUTION**  | `droid exec` defaults to Read-only mode. To run commands that leverage the files found in `.factory/commands/` or execute build scripts derived from `AGENTS.md`, an explicit flag is required: `--auto low`, `--auto medium`, or `--auto high`. The `--skip-permissions-unsafe` flag bypasses _all_ checks and is strictly advised for isolated environments. |        |

$$ \text{Execution Safety} = \text{Read-Only Mode} + \sum (\text{Autonomy Level}) + (\text{Allowlist/Denylist Filter}) $$

#### Scenario Tree: Autonomy Level Impact on Execution

The commands defined implicitly (e.g., in `AGENTS.md`) or explicitly (`.factory/commands/`) are regulated by the autonomy level chosen during execution.

```
Task: Run 'npm install' (defined in AGENTS.md)
|
[Check Autonomy Level] ‚óá
|
‚îú‚îÄ‚îÄ Level: DEFAULT (Read-only) ‚Üí ‚ùå Stop (returns non-zero exit code)
|
‚îú‚îÄ‚îÄ Level: --auto low ‚Üí ‚ùå Stop (package installation blocked)
|
‚îî‚îÄ‚îÄ Level: --auto medium ‚Üí ‚úÖ Execute (installing packages is a development operation)
|
‚îî‚îÄ‚îÄ Level: --auto high ‚Üí ‚úÖ Execute (full workflow automation)
```

Final Takeaways: Synthesized insights that are overt and cryptic (missed by superficial thinkers)

**Overt Insights:**

1.  **Configuration Centralization is Confirmed:** Droid relies heavily on the structured storage within the `.factory/` (project-scoped) and `~/.factory/` (user-scoped) directories for managing everything from model configuration (`config.json`) to security policies (`settings.json`) and executable scripts (`.factory/commands/`).
2.  **Indexing is Key to Scale:** The ability for Factory Droid to operate efficiently on multi-million token enterprise codebases stems from its pre-indexing technologies, HyperCode and ByteRank, which turn code into a graph-like structure (multi-resolution representation) rather than relying on brute-force text similarity.

**Cryptic Insights:**

1.  **The "Linter as Law" Paradigm:** The configuration structure supports Agent-Native Development, where human intent (captured in `AGENTS.md`) is enforced by machine-checkable rules (often run as commands or checks). The various `.factory/` subdirectories (`droids`, `commands`) allow developers to create executable, version-controlled constraints that ensure consistency far beyond simple code style. This transforms review overhead into auto-fixed diffs.
2.  **The Context Cost-Avoidance Mandate:** The complexity of the Context Stack (HyperCode, ByteRank, Repository Overviews) is fundamentally an optimization strategy to minimize operational cost and latency. By replacing expensive, generic LLM exploration with precise, indexed retrieval, Factory ensures that contextual awareness scales economically, validating the philosophy: "every byte of context serves a purpose". This is a defensive architecture against the economic constraints of token pricing.
